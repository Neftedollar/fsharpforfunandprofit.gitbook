---
layout: post
title: "Mathematical functions"
description: "The impetus behind functional programming"
nav: thinking-functionally
seriesId: "Thinking functionally"
seriesOrder: 2
---

Функциональное программирование вдохновлено математикой. Математические функции имеют ряд очень приятных особенностей, которые функциональные языки пытаются претворить в жизнь.


Давайте начнем с математической функции, которая добавляет 1 к числу.

	Add1(x) = x+1


Что на самом деле означает это выражение? Выглядит довольно просто. Оно означает, что существует такая операция, которая берет число и прибавляет к нему 1.



Добавим немного терминологии:



* Множество допустимых входных значений функции называются _domain_ (область определения). В данном примере, это могло быть множество действительных чисел, но сделаем жизнь проще и ограничимся здесь только целыми числами.
* Множество возможных результатов функции (область значения) называется _range_ (технически, изображение **codomain-а**). В данном случае также множество целых.
* Функцией называют _преобразование_ (в оригинале _map_) из domain-а в range. (Т.е. из области определения в область значений.)

![](../assets/img/Functions_Add1.png)
 
Вот как это определение будет выглядеть на F#.
```fsharp
let add1 x = x + 1
```


Если ввести его в F# Interactive (не забудьте про двойные точку с запятой), то можно увидеть результат ("сигнатуру" функции):

```fsharp
val add1 : int -> int
```

Рассмотрим вывод подробно:


* Общий смысл - это "функция `add1` сопоставляет целые числа (из области определения) с целыми числами (из области значений).
* "`add1`" определена как "val", сокращение от "value" (значения). Хм? что это значит? Мы обсудим значения чуть позже.
* Стрелочная нотация "->" используется, чтобы показать domain и range. В данном случае, domain является типом 'int', как и range.


Заметьте, что тип не был указан явно, но компилятор F# решил, что функция работает с int-ами. (Можно ли это изменить? Да, и скоро мы это увидим).

## Ключевые свойства математических функций ## 

Математические функции имеют ряд свойств, которые очень сильно отличают их от функций, которые используются в процедурном программировании.
* Функция всегда имеет один и тот же результат для одного и того же входного значения.
* Функция не имеет побочных эффектов.

Эти свойства дают ряд заметных преимуществ, которые функциональные языки программирования пытаются по мере сил реализовать в своем дизайне. Рассмотрим каждое из них по очереди.

###  Математические функции всегда _возвращают одинаковый результат на заданное значение_ ###

В императивном программировании мы думаем, что функции либо что-то "делают", либо что-то "подсчитывают". Математические функции ничего не считают, это чистые сопоставления из input в output. В самом деле, другое определение функции - это простое множество всех отображений. Например, очень грубо можно определить функцию "'add1'" (в C#) как

```csharp
int add1(int input)
{ 
   switch (input)
   {
   case 0: return 1;
   case 1: return 2;
   case 2: return 3;
   case 3: return 4;
   etc ad infinitum
   }
}
```

Очевидно, что невозможно иметь по case-у на каждое возможное число, но принцип тот же. При такой постановке никаких вычислений не производится, осуществляется лишь поиск.

### Математические функции свободны от побочных эффектов ###

В математической функции, входное и выходное значения логически две различные вещи, обе являющиеся предопределенными. Функция не изменяет входные или выходные данные и просто отображает предопределенное входное значение из области определения в предварительно определенное выходное значение в области значений.

Другими словами, вычисление функции _не может иметь каких либо эффектов на входные данные или еще что-нибудь в подобном роде_. Следует запомнить, что вычисление функции в действительности не считает и не манипулирует чем-либо, это просто перехваленный поиск.

Эта "иммутабельность" значений очень тонкая, но в тоже время очень важная вещь. Когда я занимаюсь математикой, я не жду, что числа будут изменяться в процессе их сложения. Например, если у меня дано:

	x = 5
	y = x+1


То я не ожидаю, что `x` изменится при добавлении к нему 1. Я ожидаю, что получу другое число (`y`), и `x` должен остаться нетронутым. В мире математики целые числа уже существуют в неизменяемом множестве, и функция "add1" просто определяет отношения между ними.

### Сила чистых функций ###

Те разновидности функций, что имеют повторяемые результаты и не имеют побочных эффектов называются "чистыми / pure функциями", и с ними можно сделать некоторые интересные вещи:

* Из легко распараллелить. Скажем, можно бы взять целые числа в диапазоне от 1 до 1000 и раздать их 1000 различных процессоров, после чего поручить каждому CPU выполнить "'add1'" над соответствующим числом, одновременно будучи уверенным, что нет необходимости в каком-либо взаимодействии между ними. Не потребуется ни блокировок, ни мьютексов, ни семафоров, ни т.п.
* Можно использовать функции лениво, вычисляя их тогда, когда это необходимо для вывода. Можно быть уверенным, что ответ будет точно таким же, независимо от того, провожу вычисления сейчас или позже.
* Можно лишь один раз провести вычисления функции для конкретного ввода, после чего закешировать результат, потому-что известно, что данный ввод будет давать такой же вывод.
* Если есть множество чистых функций, их можно вычислять в любом порядке. Опять же, это не может повлиять на финальный результат.


Соответственно, если в языке программирования есть возможность создавать чистые функции, можно немедленно получить множество мощных приемов. И несомненно, все это можно сделать в F#:


* Пример параллельных вычислений был в серии ["why use F#?"](https://fsharpforfunandprofit.com/posts/why-use-fsharp-intro/). 
* Ленивое вычисление функций будет обсуждено в серии ["optimization"](https://fsharpforfunandprofit.com/series/optimization.html).
* Кэширование результатов функций называется мемоизацией и также будет обсуждено в серии ["optimization"](https://fsharpforfunandprofit.com/series/optimization.html).
* Отсутствие необходимости в отслеживании порядка выполнения делает параллельное программирование гораздо проще и позволяет не сталкиваться с багами вызванными сменой порядка функций или рефакторинга.

## "Бесполезные" свойства математических функций ##


Математические функции также имеют некоторые свойства кажущиеся не очень полезными при программировании.

* Входные и выходные значения неизменяемы
* Функции всегда имеют один ввод и один вывод

Данные свойства отражаются в дизайне функциональных языков программирования. Стоит рассмотреть их по отдельности.

**Входные и выходные значения неизменяемы**

Иммутабельные значения в теории кажутся хорошей идеей, но как можно реально сделать какую-либо работу, если нет возможности назначить переменную традиционным способом.

Я могу заверить, что это не такая большая проблема как можно представить. Во ходе данной серией статей будет ясно, как это работает на практике.

**Математические функции всегда имеют один ввод и один вывод** 

Как видно из диаграмм, для математической функции всегда существует только один ввод и только один вывод. Это также верно для функциональных языков программирования, хотя может быть неочевидным при первом использовании.
Это похоже на большое неудобство. Как можно сделать что-либо полезное без функций с двумя (или более) параметрами?

Оказывается, существует путь сделать это, и более того он является абсолютно прозрачным на F#. Называется он "каррированием", и заслуживает отдельного поста, который появится в ближайшее время.

На самом деле, позже выяснится, что эти два "бесполезных" свойства станут невероятно ценными, и будут ключевой частью, которая делает функциональное программирование столь мощным.